apiVersion: v1
kind: ConfigMap
metadata:
  name: filestash-config-generator
  namespace: filestash
data:
  generate-config.js: |
    #!/usr/bin/env node
    /**
     * Filestash Config Generator
     * Generates config.json with properly encrypted middleware settings
     *
     * Replicates Filestash's encryption scheme:
     * - Key derivation: SHA256("PROOF_" + secret_key)[:16]
     * - Compression: zlib
     * - Encryption: AES-128-GCM
     * - Encoding: base64url
     */

    const crypto = require('crypto');
    const zlib = require('zlib');
    const fs = require('fs');
    const path = require('path');

    // Hash function matching Filestash's implementation
    function hash(str, n) {
      const h = crypto.createHash('sha256').update(str).digest();
      return h.slice(0, n);
    }

    // Encrypt using AES-GCM (matching Filestash's PerformConfigEncryption)
    function encrypt(secretKey, plaintext) {
      // Derive key the same way Filestash does
      // Step 1: SHA256("PROOF_" + secret)[:len(secret)]
      const derivedKey = hash('PROOF_' + secretKey, secretKey.length);
      // Step 2: SHA256(derivedKey)[:16] - pass Buffer directly, not string
      const key = hash(derivedKey, 16);

      // Compress with zlib
      const compressed = zlib.deflateSync(Buffer.from(plaintext), { level: 9 });

      // Create AES-GCM cipher (12-byte nonce for GCM)
      const nonce = crypto.randomBytes(12);
      const cipher = crypto.createCipheriv('aes-128-gcm', key, nonce);

      // Encrypt
      const encrypted = Buffer.concat([cipher.update(compressed), cipher.final()]);
      const authTag = cipher.getAuthTag();

      // Combine: nonce + ciphertext + authTag
      const result = Buffer.concat([nonce, encrypted, authTag]);

      // Return base64 URL encoded with padding (Go's base64.URLEncoding includes padding)
      let b64 = result.toString('base64url');
      // Add padding
      while (b64.length % 4 !== 0) {
        b64 += '=';
      }
      return b64;
    }

    // Hash password using bcrypt (requires bcryptjs to be installed)
    function hashPassword(password) {
      const bcrypt = require('bcryptjs');
      return bcrypt.hashSync(password, 10);
    }

    async function main() {
      const configPath = process.env.CONFIG_PATH || '/app/data/state/config/config.json';

      // Check if config already exists and is properly configured
      const applicationURL = process.env.APPLICATION_URL || '';
      const forceRegenerate = process.env.FORCE_REGENERATE === 'true';

      if (forceRegenerate && fs.existsSync(configPath)) {
        console.log('FORCE_REGENERATE=true, removing existing config...');
        fs.unlinkSync(configPath);
      }

      if (fs.existsSync(configPath)) {
        try {
          const existing = JSON.parse(fs.readFileSync(configPath, 'utf8'));
          // Regenerate if admin password is not set, OIDC is not configured, or host is wrong
          const hostCorrect = existing.general?.host === applicationURL;
          if (existing.auth?.admin && existing.middleware?.identity_provider && hostCorrect) {
            console.log('Config already properly configured, skipping generation');
            process.exit(0);
          }
          if (!hostCorrect) {
            console.log(`Host mismatch: ${existing.general?.host} vs ${applicationURL}, regenerating...`);
          } else {
            console.log('Existing config incomplete, regenerating...');
          }
        } catch (e) {
          console.log('Could not parse existing config, regenerating...');
        }
      }

      // Required environment variables
      let secretKey = process.env.FILESTASH_SECRET_KEY || '';
      if (!secretKey || secretKey.length < 16) {
        secretKey = crypto.randomBytes(12).toString('base64').slice(0, 16);
        console.log('Generated random secret_key');
      }

      const adminPassword = process.env.FILESTASH_ADMIN_PASSWORD || '';

      // OIDC settings
      const oidcClientID = process.env.OIDC_CLIENT_ID || '';
      const oidcClientSecret = process.env.OIDC_CLIENT_SECRET || '';
      const oidcConfigURL = process.env.OIDC_CONFIG_URL || '';

      // S3 backend settings
      const s3Endpoint = process.env.S3_ENDPOINT || '';
      const s3AccessKey = process.env.S3_ACCESS_KEY || '';
      const s3SecretKey = process.env.S3_SECRET_KEY || '';
      const s3Bucket = process.env.S3_BUCKET || '';
      const s3Region = process.env.S3_REGION || 'us-east-1';

      // Build config structure
      const config = {
        general: {
          name: 'Filestash',
          port: 8334,
          host: applicationURL,
          secret_key: secretKey,
          force_ssl: true,
        },
        auth: {},
        log: {
          level: 'INFO',
          telemetry: false,
        },
        features: {
          api: {
            enable: true,
          },
        },
      };

      // Add admin password if provided (must be under auth.admin)
      if (adminPassword) {
        config.auth.admin = hashPassword(adminPassword);
        console.log('Admin password configured');
      }

      // Add OIDC middleware if configured
      if (oidcClientID && oidcClientSecret && oidcConfigURL) {
        // Note: 'type' is at outer level, not in encrypted params
        const oidcParams = {
          client_id: oidcClientID,
          client_secret: oidcClientSecret,
          config_url: oidcConfigURL,
          scope: 'openid profile email',
        };

        const encryptedParams = encrypt(secretKey, JSON.stringify(oidcParams));

        config.middleware = {
          identity_provider: {
            type: 'openid',
            params: encryptedParams,
          },
        };
        console.log('OIDC authentication configured');
      }

      // Add S3 backend if configured
      if (s3Endpoint && s3AccessKey && s3SecretKey && s3Bucket) {
        config.connections = [
          {
            type: 's3',
            label: 'Cloud Storage',
            endpoint: s3Endpoint,
            access_key_id: s3AccessKey,
            secret_access_key: s3SecretKey,
            bucket: s3Bucket,
            region: s3Region,
            path: '/',
          },
        ];
        console.log('S3 backend configured');
      }

      // Create config directory
      const configDir = path.dirname(configPath);
      fs.mkdirSync(configDir, { recursive: true });

      // Write config
      fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
      console.log(`Config written to ${configPath}`);
    }

    main().catch((err) => {
      console.error('Error:', err.message);
      process.exit(1);
    });
